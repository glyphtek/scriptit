{"version":3,"file":"vitepress___mark__js_src_vanilla__js.js","names":["ctx","ifr","node","Mark","dct","MarkJS"],"sources":["../../../../node_modules/mark.js/src/lib/domiterator.js","../../../../node_modules/mark.js/src/lib/mark.js","../../../../node_modules/mark.js/src/vanilla.js"],"sourcesContent":["/**\n * A NodeIterator with iframes support and a method to check if an element is\n * matching a specified selector\n * @example\n * const iterator = new DOMIterator(\n *     document.querySelector(\"#context\"), true\n * );\n * iterator.forEachNode(NodeFilter.SHOW_TEXT, node => {\n *     console.log(node);\n * }, node => {\n *     if(DOMIterator.matches(node.parentNode, \".ignore\")){\n *         return NodeFilter.FILTER_REJECT;\n *     } else {\n *         return NodeFilter.FILTER_ACCEPT;\n *     }\n * }, () => {\n *     console.log(\"DONE\");\n * });\n * @todo Outsource into separate repository\n */\nexport default class DOMIterator {\n\n  /**\n   * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM\n   * element, an array of DOM elements, a NodeList or a selector\n   * @param {boolean} [iframes=true] - A boolean indicating if iframes should\n   * be handled\n   * @param {string[]} [exclude=[]] - An array containing exclusion selectors\n   * for iframes\n   * @param {number} [iframesTimeout=5000] - A number indicating the ms to\n   * wait before an iframe should be skipped, in case the load event isn't\n   * fired. This also applies if the user is offline and the resource of the\n   * iframe is online (either by the browsers \"offline\" mode or because\n   * there's no internet connection)\n   */\n  constructor(ctx, iframes = true, exclude = [], iframesTimeout = 5000) {\n    /**\n     * The context of the instance. Either a DOM element, an array of DOM\n     * elements, a NodeList or a selector\n     * @type {HTMLElement|HTMLElement[]|NodeList|string}\n     * @access protected\n     */\n    this.ctx = ctx;\n    /**\n     * Boolean indicating if iframe support is enabled\n     * @type {boolean}\n     * @access protected\n     */\n    this.iframes = iframes;\n    /**\n     * An array containing exclusion selectors for iframes\n     * @type {string[]}\n     */\n    this.exclude = exclude;\n    /**\n     * The maximum ms to wait for a load event before skipping an iframe\n     * @type {number}\n     */\n    this.iframesTimeout = iframesTimeout;\n  }\n\n  /**\n   * Checks if the specified DOM element matches the selector\n   * @param  {HTMLElement} element - The DOM element\n   * @param  {string|string[]} selector - The selector or an array with\n   * selectors\n   * @return {boolean}\n   * @access public\n   */\n  static matches(element, selector) {\n    const selectors = typeof selector === 'string' ? [selector] : selector,\n      fn = (\n        element.matches ||\n        element.matchesSelector ||\n        element.msMatchesSelector ||\n        element.mozMatchesSelector ||\n        element.oMatchesSelector ||\n        element.webkitMatchesSelector\n      );\n    if (fn) {\n      let match = false;\n      selectors.every(sel => {\n        if (fn.call(element, sel)) {\n          match = true;\n          return false;\n        }\n        return true;\n      });\n      return match;\n    } else { // may be false e.g. when el is a textNode\n      return false;\n    }\n  }\n\n  /**\n   * Returns all contexts filtered by duplicates (even nested)\n   * @return {HTMLElement[]} - An array containing DOM contexts\n   * @access protected\n   */\n  getContexts() {\n    let ctx,\n      filteredCtx = [];\n    if (typeof this.ctx === 'undefined' || !this.ctx) { // e.g. null\n      ctx = [];\n    } else if (NodeList.prototype.isPrototypeOf(this.ctx)) {\n      ctx = Array.prototype.slice.call(this.ctx);\n    } else if (Array.isArray(this.ctx)) {\n      ctx = this.ctx;\n    } else if (typeof this.ctx === 'string') {\n      ctx = Array.prototype.slice.call(\n        document.querySelectorAll(this.ctx)\n      );\n    } else { // e.g. HTMLElement or element inside iframe\n      ctx = [this.ctx];\n    }\n    // filter duplicate text nodes\n    ctx.forEach(ctx => {\n      const isDescendant = filteredCtx.filter(contexts => {\n        return contexts.contains(ctx);\n      }).length > 0;\n      if (filteredCtx.indexOf(ctx) === -1 && !isDescendant) {\n        filteredCtx.push(ctx);\n      }\n    });\n    return filteredCtx;\n  }\n\n  /**\n   * @callback DOMIterator~getIframeContentsSuccessCallback\n   * @param {HTMLDocument} contents - The contentDocument of the iframe\n   */\n  /**\n   * Calls the success callback function with the iframe document. If it can't\n   * be accessed it calls the error callback function\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @param {DOMIterator~getIframeContentsSuccessCallback} successFn\n   * @param {function} [errorFn]\n   * @access protected\n   */\n  getIframeContents(ifr, successFn, errorFn = () => {}) {\n    let doc;\n    try {\n      const ifrWin = ifr.contentWindow;\n      doc = ifrWin.document;\n      if (!ifrWin || !doc) { // no permission = null. Undefined in Phantom\n        throw new Error('iframe inaccessible');\n      }\n    } catch (e) {\n      errorFn();\n    }\n    if (doc) {\n      successFn(doc);\n    }\n  }\n\n  /**\n   * Checks if an iframe is empty (if about:blank is the shown page)\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @return {boolean}\n   * @access protected\n   */\n  isIframeBlank(ifr) {\n    const bl = 'about:blank',\n      src = ifr.getAttribute('src').trim(),\n      href = ifr.contentWindow.location.href;\n    return href === bl && src !== bl && src;\n  }\n\n  /**\n   * Observes the onload event of an iframe and calls the success callback or\n   * the error callback if the iframe is inaccessible. If the event isn't\n   * fired within the specified {@link DOMIterator#iframesTimeout}, then it'll\n   * call the error callback too\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @param {DOMIterator~getIframeContentsSuccessCallback} successFn\n   * @param {function} errorFn\n   * @access protected\n   */\n  observeIframeLoad(ifr, successFn, errorFn) {\n    let called = false,\n      tout = null;\n    const listener = () => {\n      if (called) {\n        return;\n      }\n      called = true;\n      clearTimeout(tout);\n      try {\n        if (!this.isIframeBlank(ifr)) {\n          ifr.removeEventListener('load', listener);\n          this.getIframeContents(ifr, successFn, errorFn);\n        }\n      } catch (e) { // isIframeBlank maybe throws throws an error\n        errorFn();\n      }\n    };\n    ifr.addEventListener('load', listener);\n    tout = setTimeout(listener, this.iframesTimeout);\n  }\n\n  /**\n   * Callback when the iframe is ready\n   * @callback DOMIterator~onIframeReadySuccessCallback\n   * @param {HTMLDocument} contents - The contentDocument of the iframe\n   */\n  /**\n   * Callback if the iframe can't be accessed\n   * @callback DOMIterator~onIframeReadyErrorCallback\n   */\n  /**\n   * Calls the callback if the specified iframe is ready for DOM access\n   * @param  {HTMLElement} ifr - The iframe DOM element\n   * @param  {DOMIterator~onIframeReadySuccessCallback} successFn - Success\n   * callback\n   * @param {DOMIterator~onIframeReadyErrorCallback} errorFn - Error callback\n   * @see {@link http://stackoverflow.com/a/36155560/3894981} for\n   * background information\n   * @access protected\n   */\n  onIframeReady(ifr, successFn, errorFn) {\n    try {\n      if (ifr.contentWindow.document.readyState === 'complete') {\n        if (this.isIframeBlank(ifr)) {\n          this.observeIframeLoad(ifr, successFn, errorFn);\n        } else {\n          this.getIframeContents(ifr, successFn, errorFn);\n        }\n      } else {\n        this.observeIframeLoad(ifr, successFn, errorFn);\n      }\n    } catch (e) { // accessing document failed\n      errorFn();\n    }\n  }\n\n  /**\n   * Callback when all iframes are ready for DOM access\n   * @callback DOMIterator~waitForIframesDoneCallback\n   */\n  /**\n   * Iterates over all iframes and calls the done callback when all of them\n   * are ready for DOM access (including nested ones)\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~waitForIframesDoneCallback} done - Done callback\n   */\n  waitForIframes(ctx, done) {\n    let eachCalled = 0;\n    this.forEachIframe(ctx, () => true, ifr => {\n      eachCalled++;\n      this.waitForIframes(ifr.querySelector('html'), () => {\n        if (!(--eachCalled)) {\n          done();\n        }\n      });\n    }, handled => {\n      if (!handled) {\n        done();\n      }\n    });\n  }\n\n  /**\n   * Callback allowing to filter an iframe. Must return true when the element\n   * should remain, otherwise false\n   * @callback DOMIterator~forEachIframeFilterCallback\n   * @param {HTMLElement} iframe - The iframe DOM element\n   */\n  /**\n   * Callback for each iframe content\n   * @callback DOMIterator~forEachIframeEachCallback\n   * @param {HTMLElement} content - The iframe document\n   */\n  /**\n   * Callback if all iframes inside the context were handled\n   * @callback DOMIterator~forEachIframeEndCallback\n   * @param {number} handled - The number of handled iframes (those who\n   * wheren't filtered)\n   */\n  /**\n   * Iterates over all iframes inside the specified context and calls the\n   * callbacks when they're ready. Filters iframes based on the instance\n   * exclusion selectors\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~forEachIframeFilterCallback} filter - Filter callback\n   * @param {DOMIterator~forEachIframeEachCallback} each - Each callback\n   * @param {DOMIterator~forEachIframeEndCallback} [end] - End callback\n   * @access protected\n   */\n  forEachIframe(ctx, filter, each, end = () => {}) {\n    let ifr = ctx.querySelectorAll('iframe'),\n      open = ifr.length,\n      handled = 0;\n    ifr = Array.prototype.slice.call(ifr);\n    const checkEnd = () => {\n      if (--open <= 0) {\n        end(handled);\n      }\n    };\n    if (!open) {\n      checkEnd();\n    }\n    ifr.forEach(ifr => {\n      if (DOMIterator.matches(ifr, this.exclude)) {\n        checkEnd();\n      } else {\n        this.onIframeReady(ifr, con => {\n          if (filter(ifr)) {\n            handled++;\n            each(con);\n          }\n          checkEnd();\n        }, checkEnd);\n      }\n    });\n  }\n\n  /**\n   * Creates a NodeIterator on the specified context\n   * @see {@link https://developer.mozilla.org/en/docs/Web/API/NodeIterator}\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param {DOMIterator~filterCb} filter\n   * @return {NodeIterator}\n   * @access protected\n   */\n  createIterator(ctx, whatToShow, filter) {\n    return document.createNodeIterator(ctx, whatToShow, filter, false);\n  }\n\n  /**\n   * Creates an instance of DOMIterator in an iframe\n   * @param {HTMLDocument} contents - Iframe document\n   * @return {DOMIterator}\n   * @access protected\n   */\n  createInstanceOnIframe(contents) {\n    return new DOMIterator(contents.querySelector('html'), this.iframes);\n  }\n\n  /**\n   * Checks if an iframe occurs between two nodes, more specifically if an\n   * iframe occurs before the specified node and after the specified prevNode\n   * @param {HTMLElement} node - The node that should occur after the iframe\n   * @param {HTMLElement} prevNode - The node that should occur before the\n   * iframe\n   * @param {HTMLElement} ifr - The iframe to check against\n   * @return {boolean}\n   * @access protected\n   */\n  compareNodeIframe(node, prevNode, ifr) {\n    const compCurr = node.compareDocumentPosition(ifr),\n      prev = Node.DOCUMENT_POSITION_PRECEDING;\n    if (compCurr & prev) {\n      if (prevNode !== null) {\n        const compPrev = prevNode.compareDocumentPosition(ifr),\n          after = Node.DOCUMENT_POSITION_FOLLOWING;\n        if (compPrev & after) {\n          return true;\n        }\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @typedef {DOMIterator~getIteratorNodeReturn}\n   * @type {object.<string>}\n   * @property {HTMLElement} prevNode - The previous node or null if there is\n   * no\n   * @property {HTMLElement} node - The current node\n   */\n  /**\n   * Returns the previous and current node of the specified iterator\n   * @param {NodeIterator} itr - The iterator\n   * @return {DOMIterator~getIteratorNodeReturn}\n   * @access protected\n   */\n  getIteratorNode(itr) {\n    const prevNode = itr.previousNode();\n    let node;\n    if (prevNode === null) {\n      node = itr.nextNode();\n    } else {\n      node = itr.nextNode() && itr.nextNode();\n    }\n    return {\n      prevNode,\n      node\n    };\n  }\n\n  /**\n   * An array containing objects. The object key \"val\" contains an iframe\n   * DOM element. The object key \"handled\" contains a boolean indicating if\n   * the iframe was handled already.\n   * It wouldn't be enough to save all open or all already handled iframes.\n   * The information of open iframes is necessary because they may occur after\n   * all other text nodes (and compareNodeIframe would never be true). The\n   * information of already handled iframes is necessary as otherwise they may\n   * be handled multiple times\n   * @typedef DOMIterator~checkIframeFilterIfr\n   * @type {object[]}\n   */\n  /**\n   * Checks if an iframe wasn't handled already and if so, calls\n   * {@link DOMIterator#compareNodeIframe} to check if it should be handled.\n   * Information wheter an iframe was or wasn't handled is given within the\n   * <code>ifr</code> dictionary\n   * @param {HTMLElement} node - The node that should occur after the iframe\n   * @param {HTMLElement} prevNode - The node that should occur before the\n   * iframe\n   * @param {HTMLElement} currIfr - The iframe to check\n   * @param {DOMIterator~checkIframeFilterIfr} ifr - The iframe dictionary.\n   * Will be manipulated (by reference)\n   * @return {boolean} Returns true when it should be handled, otherwise false\n   * @access protected\n   */\n  checkIframeFilter(node, prevNode, currIfr, ifr) {\n    let key = false, // false === doesn't exist\n      handled = false;\n    ifr.forEach((ifrDict, i) => {\n      if (ifrDict.val === currIfr) {\n        key = i;\n        handled = ifrDict.handled;\n      }\n    });\n    if (this.compareNodeIframe(node, prevNode, currIfr)) {\n      if (key === false && !handled) {\n        ifr.push({\n          val: currIfr,\n          handled: true\n        });\n      } else if (key !== false && !handled) {\n        ifr[key].handled = true;\n      }\n      return true;\n    }\n    if (key === false) {\n      ifr.push({\n        val: currIfr,\n        handled: false\n      });\n    }\n    return false;\n  }\n\n  /**\n   * Creates an iterator on all open iframes in the specified array and calls\n   * the end callback when finished\n   * @param {DOMIterator~checkIframeFilterIfr} ifr\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param  {DOMIterator~forEachNodeCallback} eCb - Each callback\n   * @param {DOMIterator~filterCb} fCb\n   * @access protected\n   */\n  handleOpenIframes(ifr, whatToShow, eCb, fCb) {\n    ifr.forEach(ifrDict => {\n      if (!ifrDict.handled) {\n        this.getIframeContents(ifrDict.val, con => {\n          this.createInstanceOnIframe(con).forEachNode(\n            whatToShow, eCb, fCb\n          );\n        });\n      }\n    });\n  }\n\n  /**\n   * Iterates through all nodes in the specified context and handles iframe\n   * nodes at the correct position\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param {HTMLElement} ctx - The context\n   * @param  {DOMIterator~forEachNodeCallback} eachCb - Each callback\n   * @param {DOMIterator~filterCb} filterCb - Filter callback\n   * @param {DOMIterator~forEachNodeEndCallback} doneCb - End callback\n   * @access protected\n   */\n  iterateThroughNodes(whatToShow, ctx, eachCb, filterCb, doneCb) {\n    const itr = this.createIterator(ctx, whatToShow, filterCb);\n    let ifr = [],\n      elements = [],\n      node, prevNode, retrieveNodes = () => {\n        ({\n          prevNode,\n          node\n        } = this.getIteratorNode(itr));\n        return node;\n      };\n    while (retrieveNodes()) {\n      if (this.iframes) {\n        this.forEachIframe(ctx, currIfr => {\n          // note that ifr will be manipulated here\n          return this.checkIframeFilter(node, prevNode, currIfr, ifr);\n        }, con => {\n          this.createInstanceOnIframe(con).forEachNode(\n            whatToShow, ifrNode => elements.push(ifrNode), filterCb\n          );\n        });\n      }\n      // it's faster to call the each callback in an array loop\n      // than in this while loop\n      elements.push(node);\n    }\n    elements.forEach(node => {\n      eachCb(node);\n    });\n    if (this.iframes) {\n      this.handleOpenIframes(ifr, whatToShow, eachCb, filterCb);\n    }\n    doneCb();\n  }\n\n  /**\n   * Callback for each node\n   * @callback DOMIterator~forEachNodeCallback\n   * @param {HTMLElement} node - The DOM text node element\n   */\n  /**\n   * Callback if all contexts were handled\n   * @callback DOMIterator~forEachNodeEndCallback\n   */\n  /**\n   * Iterates over all contexts and initializes\n   * {@link DOMIterator#iterateThroughNodes iterateThroughNodes} on them\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param  {DOMIterator~forEachNodeCallback} each - Each callback\n   * @param {DOMIterator~filterCb} filter - Filter callback\n   * @param {DOMIterator~forEachNodeEndCallback} done - End callback\n   * @access public\n   */\n  forEachNode(whatToShow, each, filter, done = () => {}) {\n    const contexts = this.getContexts();\n    let open = contexts.length;\n    if (!open) {\n      done();\n    }\n    contexts.forEach(ctx => {\n      const ready = () => {\n        this.iterateThroughNodes(whatToShow, ctx, each, filter, () => {\n          if (--open <= 0) { // call end all contexts were handled\n            done();\n          }\n        });\n      };\n      // wait for iframes to avoid recursive calls, otherwise this would\n      // perhaps reach the recursive function call limit with many nodes\n      if (this.iframes) {\n        this.waitForIframes(ctx, ready);\n      } else {\n        ready();\n      }\n    });\n  }\n\n  /**\n   * Callback to filter nodes. Can return e.g. NodeFilter.FILTER_ACCEPT or\n   * NodeFilter.FILTER_REJECT\n   * @see {@link http://tinyurl.com/zdczmm2}\n   * @callback DOMIterator~filterCb\n   * @param {HTMLElement} node - The node to filter\n   */\n  /**\n   * @typedef DOMIterator~whatToShow\n   * @see {@link http://tinyurl.com/zfqqkx2}\n   * @type {number}\n   */\n}\n","import DOMIterator from './domiterator';\n\n/**\n * Marks search terms in DOM elements\n * @example\n * new Mark(document.querySelector(\".context\")).mark(\"lorem ipsum\");\n * @example\n * new Mark(document.querySelector(\".context\")).markRegExp(/lorem/gmi);\n */\nexport default class Mark { // eslint-disable-line no-unused-vars\n\n  /**\n   * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM\n   * element, an array of DOM elements, a NodeList or a selector\n   */\n  constructor(ctx) {\n    /**\n     * The context of the instance. Either a DOM element, an array of DOM\n     * elements, a NodeList or a selector\n     * @type {HTMLElement|HTMLElement[]|NodeList|string}\n     * @access protected\n     */\n    this.ctx = ctx;\n    /**\n     * Specifies if the current browser is a IE (necessary for the node\n     * normalization bug workaround). See {@link Mark#unwrapMatches}\n     * @type {boolean}\n     * @access protected\n     */\n    this.ie = false;\n    const ua = window.navigator.userAgent;\n    if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) {\n      this.ie = true;\n    }\n  }\n\n  /**\n   * Options defined by the user. They will be initialized from one of the\n   * public methods. See {@link Mark#mark}, {@link Mark#markRegExp},\n   * {@link Mark#markRanges} and {@link Mark#unmark} for option properties.\n   * @type {object}\n   * @param {object} [val] - An object that will be merged with defaults\n   * @access protected\n   */\n  set opt(val) {\n    this._opt = Object.assign({}, {\n      'element': '',\n      'className': '',\n      'exclude': [],\n      'iframes': false,\n      'iframesTimeout': 5000,\n      'separateWordSearch': true,\n      'diacritics': true,\n      'synonyms': {},\n      'accuracy': 'partially',\n      'acrossElements': false,\n      'caseSensitive': false,\n      'ignoreJoiners': false,\n      'ignoreGroups': 0,\n      'ignorePunctuation': [],\n      'wildcards': 'disabled',\n      'each': () => {},\n      'noMatch': () => {},\n      'filter': () => true,\n      'done': () => {},\n      'debug': false,\n      'log': window.console\n    }, val);\n  }\n\n  get opt() {\n    return this._opt;\n  }\n\n  /**\n   * An instance of DOMIterator\n   * @type {DOMIterator}\n   * @access protected\n   */\n  get iterator() {\n    // always return new instance in case there were option changes\n    return new DOMIterator(\n      this.ctx,\n      this.opt.iframes,\n      this.opt.exclude,\n      this.opt.iframesTimeout\n    );\n  }\n\n  /**\n   * Logs a message if log is enabled\n   * @param {string} msg - The message to log\n   * @param {string} [level=\"debug\"] - The log level, e.g. <code>warn</code>\n   * <code>error</code>, <code>debug</code>\n   * @access protected\n   */\n  log(msg, level = 'debug') {\n    const log = this.opt.log;\n    if (!this.opt.debug) {\n      return;\n    }\n    if (typeof log === 'object' && typeof log[level] === 'function') {\n      log[level](`mark.js: ${msg}`);\n    }\n  }\n\n  /**\n   * Escapes a string for usage within a regular expression\n   * @param {string} str - The string to escape\n   * @return {string}\n   * @access protected\n   */\n  escapeStr(str) {\n    // eslint-disable-next-line no-useless-escape\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n  }\n\n  /**\n   * Creates a regular expression string to match the specified search\n   * term including synonyms, diacritics and accuracy if defined\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createRegExp(str) {\n    if (this.opt.wildcards !== 'disabled') {\n      str = this.setupWildcardsRegExp(str);\n    }\n    str = this.escapeStr(str);\n    if (Object.keys(this.opt.synonyms).length) {\n      str = this.createSynonymsRegExp(str);\n    }\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.setupIgnoreJoinersRegExp(str);\n    }\n    if (this.opt.diacritics) {\n      str = this.createDiacriticsRegExp(str);\n    }\n    str = this.createMergedBlanksRegExp(str);\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.createJoinersRegExp(str);\n    }\n    if (this.opt.wildcards !== 'disabled') {\n      str = this.createWildcardsRegExp(str);\n    }\n    str = this.createAccuracyRegExp(str);\n    return str;\n  }\n\n  /**\n   * Creates a regular expression string to match the defined synonyms\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createSynonymsRegExp(str) {\n    const syn = this.opt.synonyms,\n      sens = this.opt.caseSensitive ? '' : 'i',\n      // add replacement character placeholder before and after the\n      // synonym group\n      joinerPlaceholder = this.opt.ignoreJoiners ||\n                this.opt.ignorePunctuation.length ? '\\u0000' : '';\n    for (let index in syn) {\n      if (syn.hasOwnProperty(index)) {\n        const value = syn[index],\n          k1 = this.opt.wildcards !== 'disabled' ?\n            this.setupWildcardsRegExp(index) :\n            this.escapeStr(index),\n          k2 = this.opt.wildcards !== 'disabled' ?\n            this.setupWildcardsRegExp(value) :\n            this.escapeStr(value);\n        if (k1 !== '' && k2 !== '') {\n          str = str.replace(\n            new RegExp(\n              `(${this.escapeStr(k1)}|${this.escapeStr(k2)})`,\n              `gm${sens}`\n            ),\n            joinerPlaceholder +\n            `(${this.processSynomyms(k1)}|` +\n            `${this.processSynomyms(k2)})` +\n            joinerPlaceholder\n          );\n        }\n      }\n    }\n    return str;\n  }\n\n  /**\n   * Setup synonyms to work with ignoreJoiners and or ignorePunctuation\n   * @param {string} str - synonym key or value to process\n   * @return {string} - processed synonym string\n   */\n  processSynomyms(str) {\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.setupIgnoreJoinersRegExp(str);\n    }\n    return str;\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * wildcard regular expression matches\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  setupWildcardsRegExp(str) {\n    // replace single character wildcard with unicode 0001\n    str = str.replace(/(?:\\\\)*\\?/g, val => {\n      return val.charAt(0) === '\\\\' ? '?' : '\\u0001';\n    });\n    // replace multiple character wildcard with unicode 0002\n    return str.replace(/(?:\\\\)*\\*/g, val => {\n      return val.charAt(0) === '\\\\' ? '*' : '\\u0002';\n    });\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * wildcard regular expression matches\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createWildcardsRegExp(str) {\n    // default to \"enable\" (i.e. to not include spaces)\n    // \"withSpaces\" uses `[\\\\S\\\\s]` instead of `.` because the latter\n    // does not match new line characters\n    let spaces = this.opt.wildcards === 'withSpaces';\n    return str\n    // replace unicode 0001 with a RegExp class to match any single\n    // character, or any single non-whitespace character depending\n    // on the setting\n      .replace(/\\u0001/g, spaces ? '[\\\\S\\\\s]?' : '\\\\S?')\n    // replace unicode 0002 with a RegExp class to match zero or\n    // more characters, or zero or more non-whitespace characters\n    // depending on the setting\n      .replace(/\\u0002/g, spaces ? '[\\\\S\\\\s]*?' : '\\\\S*');\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * designated characters (soft hyphens & zero width characters)\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  setupIgnoreJoinersRegExp(str) {\n    // adding a \"null\" unicode character as it will not be modified by the\n    // other \"create\" regular expression functions\n    return str.replace(/[^(|)\\\\]/g, (val, indx, original) => {\n      // don't add a null after an opening \"(\", around a \"|\" or before\n      // a closing \"(\", or between an escapement (e.g. \\+)\n      let nextChar = original.charAt(indx + 1);\n      if (/[(|)\\\\]/.test(nextChar) || nextChar === '') {\n        return val;\n      } else {\n        return val + '\\u0000';\n      }\n    });\n  }\n\n  /**\n   * Creates a regular expression string to allow ignoring of designated\n   * characters (soft hyphens, zero width characters & punctuation) based on\n   * the specified option values of <code>ignorePunctuation</code> and\n   * <code>ignoreJoiners</code>\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createJoinersRegExp(str) {\n    let joiner = [];\n    const ignorePunctuation = this.opt.ignorePunctuation;\n    if (Array.isArray(ignorePunctuation) && ignorePunctuation.length) {\n      joiner.push(this.escapeStr(ignorePunctuation.join('')));\n    }\n    if (this.opt.ignoreJoiners) {\n      // u+00ad = soft hyphen\n      // u+200b = zero-width space\n      // u+200c = zero-width non-joiner\n      // u+200d = zero-width joiner\n      joiner.push('\\\\u00ad\\\\u200b\\\\u200c\\\\u200d');\n    }\n    return joiner.length ?\n      str.split(/\\u0000+/).join(`[${joiner.join('')}]*`) :\n      str;\n  }\n\n  /**\n   * Creates a regular expression string to match diacritics\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createDiacriticsRegExp(str) {\n    const sens = this.opt.caseSensitive ? '' : 'i',\n      dct = this.opt.caseSensitive ? [\n        'aàáảãạăằắẳẵặâầấẩẫậäåāą', 'AÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ',\n        'cçćč', 'CÇĆČ', 'dđď', 'DĐĎ',\n        'eèéẻẽẹêềếểễệëěēę', 'EÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ',\n        'iìíỉĩịîïī', 'IÌÍỈĨỊÎÏĪ', 'lł', 'LŁ', 'nñňń',\n        'NÑŇŃ', 'oòóỏõọôồốổỗộơởỡớờợöøō', 'OÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ',\n        'rř', 'RŘ', 'sšśșş', 'SŠŚȘŞ',\n        'tťțţ', 'TŤȚŢ', 'uùúủũụưừứửữựûüůū', 'UÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ',\n        'yýỳỷỹỵÿ', 'YÝỲỶỸỴŸ', 'zžżź', 'ZŽŻŹ'\n      ] : [\n        'aàáảãạăằắẳẵặâầấẩẫậäåāąAÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ', 'cçćčCÇĆČ',\n        'dđďDĐĎ', 'eèéẻẽẹêềếểễệëěēęEÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ',\n        'iìíỉĩịîïīIÌÍỈĨỊÎÏĪ', 'lłLŁ', 'nñňńNÑŇŃ',\n        'oòóỏõọôồốổỗộơởỡớờợöøōOÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ', 'rřRŘ',\n        'sšśșşSŠŚȘŞ', 'tťțţTŤȚŢ',\n        'uùúủũụưừứửữựûüůūUÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ', 'yýỳỷỹỵÿYÝỲỶỸỴŸ', 'zžżźZŽŻŹ'\n      ];\n    let handled = [];\n    str.split('').forEach(ch => {\n      dct.every(dct => {\n        // Check if the character is inside a diacritics list\n        if (dct.indexOf(ch) !== -1) {\n          // Check if the related diacritics list was not\n          // handled yet\n          if (handled.indexOf(dct) > -1) {\n            return false;\n          }\n          // Make sure that the character OR any other\n          // character in the diacritics list will be matched\n          str = str.replace(\n            new RegExp(`[${dct}]`, `gm${sens}`), `[${dct}]`\n          );\n          handled.push(dct);\n        }\n        return true;\n      });\n    });\n    return str;\n  }\n\n  /**\n   * Creates a regular expression string that merges whitespace characters\n   * including subsequent ones into a single pattern, one or multiple\n   * whitespaces\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createMergedBlanksRegExp(str) {\n    return str.replace(/[\\s]+/gmi, '[\\\\s]+');\n  }\n\n  /**\n   * Creates a regular expression string to match the specified string with\n   * the defined accuracy. As in the regular expression of \"exactly\" can be\n   * a group containing a blank at the beginning, all regular expressions will\n   * be created with two groups. The first group can be ignored (may contain\n   * the said blank), the second contains the actual match\n   * @param  {string} str - The searm term to be used\n   * @return {str}\n   * @access protected\n   */\n  createAccuracyRegExp(str) {\n    const chars = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~¡¿';\n    let acc = this.opt.accuracy,\n      val = typeof acc === 'string' ? acc : acc.value,\n      ls = typeof acc === 'string' ? [] : acc.limiters,\n      lsJoin = '';\n    ls.forEach(limiter => {\n      lsJoin += `|${this.escapeStr(limiter)}`;\n    });\n    switch (val) {\n    case 'partially':\n    default:\n      return `()(${str})`;\n    case 'complementary':\n      lsJoin = '\\\\s' + (lsJoin ? lsJoin : this.escapeStr(chars));\n      return `()([^${lsJoin}]*${str}[^${lsJoin}]*)`;\n    case 'exactly':\n      return `(^|\\\\s${lsJoin})(${str})(?=$|\\\\s${lsJoin})`;\n    }\n  }\n\n  /**\n   * @typedef Mark~separatedKeywords\n   * @type {object.<string>}\n   * @property {array.<string>} keywords - The list of keywords\n   * @property {number} length - The length\n   */\n  /**\n   * Returns a list of keywords dependent on whether separate word search\n   * was defined. Also it filters empty keywords\n   * @param {array} sv - The array of keywords\n   * @return {Mark~separatedKeywords}\n   * @access protected\n   */\n  getSeparatedKeywords(sv) {\n    let stack = [];\n    sv.forEach(kw => {\n      if (!this.opt.separateWordSearch) {\n        if (kw.trim() && stack.indexOf(kw) === -1) {\n          stack.push(kw);\n        }\n      } else {\n        kw.split(' ').forEach(kwSplitted => {\n          if (kwSplitted.trim() && stack.indexOf(kwSplitted) === -1) {\n            stack.push(kwSplitted);\n          }\n        });\n      }\n    });\n    return {\n      // sort because of https://git.io/v6USg\n      'keywords': stack.sort((a, b) => {\n        return b.length - a.length;\n      }),\n      'length': stack.length\n    };\n  }\n\n  /**\n   * Check if a value is a number\n   * @param {number|string} value - the value to check;\n   * numeric strings allowed\n   * @return {boolean}\n   * @access protected\n   */\n  isNumeric(value) {\n    // http://stackoverflow.com/a/16655847/145346\n    // eslint-disable-next-line eqeqeq\n    return Number(parseFloat(value)) == value;\n  }\n\n  /**\n   * @typedef Mark~rangeObject\n   * @type {object}\n   * @property {number} start - The start position within the composite value\n   * @property {number} length - The length of the string to mark within the\n   * composite value.\n   */\n  /**\n   * @typedef Mark~setOfRanges\n   * @type {object[]}\n   * @property {Mark~rangeObject}\n   */\n  /**\n   * Returns a processed list of integer offset indexes that do not overlap\n   * each other, and remove any string values or additional elements\n   * @param {Mark~setOfRanges} array - unprocessed raw array\n   * @return {Mark~setOfRanges} - processed array with any invalid entries\n   * removed\n   * @throws Will throw an error if an array of objects is not passed\n   * @access protected\n   */\n  checkRanges(array) {\n    // start and length indexes are included in an array of objects\n    // [{start: 0, length: 1}, {start: 4, length: 5}]\n    // quick validity check of the first entry only\n    if (\n      !Array.isArray(array) ||\n      Object.prototype.toString.call( array[0] ) !== '[object Object]'\n    ) {\n      this.log('markRanges() will only accept an array of objects');\n      this.opt.noMatch(array);\n      return [];\n    }\n    const stack = [];\n    let last = 0;\n    array\n    // acending sort to ensure there is no overlap in start & end\n    // offsets\n      .sort((a, b) => {\n        return a.start - b.start;\n      })\n      .forEach(item => {\n        let {start, end, valid} = this.callNoMatchOnInvalidRanges(item, last);\n        if (valid) {\n          // preserve item in case there are extra key:values within\n          item.start = start;\n          item.length = end - start;\n          stack.push(item);\n          last = end;\n        }\n      });\n    return stack;\n  }\n\n  /**\n   * @typedef Mark~validObject\n   * @type {object}\n   * @property {number} start - The start position within the composite value\n   * @property {number} end - The calculated end position within the composite\n   * value.\n   * @property {boolean} valid - boolean value indicating that the start and\n   * calculated end range is valid\n   */\n  /**\n    * Initial validation of ranges for markRanges. Preliminary checks are done\n    * to ensure the start and length values exist and are not zero or non-\n    * numeric\n    * @param {Mark~rangeObject} range - the current range object\n    * @param {number} last - last index of range\n    * @return {Mark~validObject}\n    * @access protected\n    */\n  callNoMatchOnInvalidRanges(range, last) {\n    let start, end,\n      valid = false;\n    if (range && typeof range.start !== 'undefined') {\n      start = parseInt(range.start, 10);\n      end = start + parseInt(range.length, 10);\n      // ignore overlapping values & non-numeric entries\n      if (\n        this.isNumeric(range.start) &&\n        this.isNumeric(range.length) &&\n        end - last > 0 &&\n        end - start > 0\n      ) {\n        valid = true;\n      } else {\n        this.log(\n          'Ignoring invalid or overlapping range: ' +\n                    `${JSON.stringify(range)}`\n        );\n        this.opt.noMatch(range);\n      }\n    } else {\n      this.log(`Ignoring invalid range: ${JSON.stringify(range)}`);\n      this.opt.noMatch(range);\n    }\n    return {\n      start: start,\n      end: end,\n      valid: valid\n    };\n  }\n\n  /**\n   * Check valid range for markRanges. Check ranges with access to the context\n   * string. Range values are double checked, lengths that extend the mark\n   * beyond the string length are limitied and ranges containing only\n   * whitespace are ignored\n   * @param {Mark~rangeObject} range - the current range object\n   * @param {number} originalLength - original length of the context string\n   * @param {string} string - current content string\n   * @return {Mark~validObject}\n   * @access protected\n   */\n  checkWhitespaceRanges(range, originalLength, string) {\n    let end,\n      valid = true,\n      // the max value changes after the DOM is manipulated\n      max = string.length,\n      // adjust offset to account for wrapped text node\n      offset = originalLength - max,\n      start = parseInt(range.start, 10) - offset;\n    // make sure to stop at max\n    start = start > max ? max : start;\n    end = start + parseInt(range.length, 10);\n    if (end > max) {\n      end = max;\n      this.log(`End range automatically set to the max value of ${max}`);\n    }\n    if (start < 0 || end - start < 0 || start > max || end > max) {\n      valid = false;\n      this.log(`Invalid range: ${JSON.stringify(range)}`);\n      this.opt.noMatch(range);\n    } else if (string.substring(start, end).replace(/\\s+/g, '') === '') {\n      valid = false;\n      // whitespace only; even if wrapped it is not visible\n      this.log('Skipping whitespace only range: ' +JSON.stringify(range));\n      this.opt.noMatch(range);\n    }\n    return {\n      start: start,\n      end: end,\n      valid: valid\n    };\n  }\n\n  /**\n   * @typedef Mark~getTextNodesDict\n   * @type {object.<string>}\n   * @property {string} value - The composite value of all text nodes\n   * @property {object[]} nodes - An array of objects\n   * @property {number} nodes.start - The start position within the composite\n   * value\n   * @property {number} nodes.end - The end position within the composite\n   * value\n   * @property {HTMLElement} nodes.node - The DOM text node element\n   */\n  /**\n   * Callback\n   * @callback Mark~getTextNodesCallback\n   * @param {Mark~getTextNodesDict}\n   */\n  /**\n   * Calls the callback with an object containing all text nodes (including\n   * iframe text nodes) with start and end positions and the composite value\n   * of them (string)\n   * @param {Mark~getTextNodesCallback} cb - Callback\n   * @access protected\n   */\n  getTextNodes(cb) {\n    let val = '',\n      nodes = [];\n    this.iterator.forEachNode(NodeFilter.SHOW_TEXT, node => {\n      nodes.push({\n        start: val.length,\n        end: (val += node.textContent).length,\n        node\n      });\n    }, node => {\n      if (this.matchesExclude(node.parentNode)) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }, () => {\n      cb({\n        value: val,\n        nodes: nodes\n      });\n    });\n  }\n\n  /**\n   * Checks if an element matches any of the specified exclude selectors. Also\n   * it checks for elements in which no marks should be performed (e.g.\n   * script and style tags) and optionally already marked elements\n   * @param  {HTMLElement} el - The element to check\n   * @return {boolean}\n   * @access protected\n   */\n  matchesExclude(el) {\n    return DOMIterator.matches(el, this.opt.exclude.concat([\n      // ignores the elements itself, not their childrens (selector *)\n      'script', 'style', 'title', 'head', 'html'\n    ]));\n  }\n\n  /**\n   * Wraps the instance element and class around matches that fit the start\n   * and end positions within the node\n   * @param  {HTMLElement} node - The DOM text node\n   * @param  {number} start - The position where to start wrapping\n   * @param  {number} end - The position where to end wrapping\n   * @return {HTMLElement} Returns the splitted text node that will appear\n   * after the wrapped text node\n   * @access protected\n   */\n  wrapRangeInTextNode(node, start, end) {\n    const hEl = !this.opt.element ? 'mark' : this.opt.element,\n      startNode = node.splitText(start),\n      ret = startNode.splitText(end - start);\n    let repl = document.createElement(hEl);\n    repl.setAttribute('data-markjs', 'true');\n    if (this.opt.className) {\n      repl.setAttribute('class', this.opt.className);\n    }\n    repl.textContent = startNode.textContent;\n    startNode.parentNode.replaceChild(repl, startNode);\n    return ret;\n  }\n\n  /**\n   * @typedef Mark~wrapRangeInMappedTextNodeDict\n   * @type {object.<string>}\n   * @property {string} value - The composite value of all text nodes\n   * @property {object[]} nodes - An array of objects\n   * @property {number} nodes.start - The start position within the composite\n   * value\n   * @property {number} nodes.end - The end position within the composite\n   * value\n   * @property {HTMLElement} nodes.node - The DOM text node element\n   */\n  /**\n   * Each callback\n   * @callback Mark~wrapMatchesEachCallback\n   * @param {HTMLElement} node - The wrapped DOM element\n   * @param {number} lastIndex - The last matching position within the\n   * composite value of text nodes\n   */\n  /**\n   * Filter callback\n   * @callback Mark~wrapMatchesFilterCallback\n   * @param {HTMLElement} node - The matching text node DOM element\n   */\n  /**\n   * Determines matches by start and end positions using the text node\n   * dictionary even across text nodes and calls\n   * {@link Mark#wrapRangeInTextNode} to wrap them\n   * @param  {Mark~wrapRangeInMappedTextNodeDict} dict - The dictionary\n   * @param  {number} start - The start position of the match\n   * @param  {number} end - The end position of the match\n   * @param  {Mark~wrapMatchesFilterCallback} filterCb - Filter callback\n   * @param  {Mark~wrapMatchesEachCallback} eachCb - Each callback\n   * @access protected\n   */\n  wrapRangeInMappedTextNode(dict, start, end, filterCb, eachCb) {\n    // iterate over all text nodes to find the one matching the positions\n    dict.nodes.every((n, i) => {\n      const sibl = dict.nodes[i + 1];\n      if (typeof sibl === 'undefined' || sibl.start > start) {\n        if (!filterCb(n.node)) {\n          return false;\n        }\n        // map range from dict.value to text node\n        const s = start - n.start,\n          e = (end > n.end ? n.end : end) - n.start,\n          startStr = dict.value.substr(0, n.start),\n          endStr = dict.value.substr(e + n.start);\n        n.node = this.wrapRangeInTextNode(n.node, s, e);\n        // recalculate positions to also find subsequent matches in the\n        // same text node. Necessary as the text node in dict now only\n        // contains the splitted part after the wrapped one\n        dict.value = startStr + endStr;\n        dict.nodes.forEach((k, j) => {\n          if (j >= i) {\n            if (dict.nodes[j].start > 0 && j !== i) {\n              dict.nodes[j].start -= e;\n            }\n            dict.nodes[j].end -= e;\n          }\n        });\n        end -= e;\n        eachCb(n.node.previousSibling, n.start);\n        if (end > n.end) {\n          start = n.end;\n        } else {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapMatchesFilterCallback\n   * @param {string} match - The matching string\n   * @param {HTMLElement} node - The text node where the match occurs\n   */\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapMatchesEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapMatchesEndCallback\n   */\n  /**\n   * Wraps the instance element and class around matches within single HTML\n   * elements in all contexts\n   * @param {RegExp} regex - The regular expression to be searched for\n   * @param {number} ignoreGroups - A number indicating the amount of RegExp\n   * matching groups to ignore\n   * @param {Mark~wrapMatchesFilterCallback} filterCb\n   * @param {Mark~wrapMatchesEachCallback} eachCb\n   * @param {Mark~wrapMatchesEndCallback} endCb\n   * @access protected\n   */\n  wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {\n    const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n    this.getTextNodes(dict => {\n      dict.nodes.forEach(node => {\n        node = node.node;\n        let match;\n        while (\n          (match = regex.exec(node.textContent)) !== null &&\n          match[matchIdx] !== ''\n        ) {\n          if (!filterCb(match[matchIdx], node)) {\n            continue;\n          }\n          let pos = match.index;\n          if (matchIdx !== 0) {\n            for (let i = 1; i < matchIdx; i++) {\n              pos += match[i].length;\n            }\n          }\n          node = this.wrapRangeInTextNode(\n            node,\n            pos,\n            pos + match[matchIdx].length\n          );\n          eachCb(node.previousSibling);\n          // reset index of last match as the node changed and the\n          // index isn't valid anymore http://tinyurl.com/htsudjd\n          regex.lastIndex = 0;\n        }\n      });\n      endCb();\n    });\n  }\n\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapMatchesAcrossElementsEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapMatchesAcrossElementsFilterCallback\n   * @param {string} match - The matching string\n   * @param {HTMLElement} node - The text node where the match occurs\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapMatchesAcrossElementsEndCallback\n   */\n  /**\n   * Wraps the instance element and class around matches across all HTML\n   * elements in all contexts\n   * @param {RegExp} regex - The regular expression to be searched for\n   * @param {number} ignoreGroups - A number indicating the amount of RegExp\n   * matching groups to ignore\n   * @param {Mark~wrapMatchesAcrossElementsFilterCallback} filterCb\n   * @param {Mark~wrapMatchesAcrossElementsEachCallback} eachCb\n   * @param {Mark~wrapMatchesAcrossElementsEndCallback} endCb\n   * @access protected\n   */\n  wrapMatchesAcrossElements(regex, ignoreGroups, filterCb, eachCb, endCb) {\n    const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n    this.getTextNodes(dict => {\n      let match;\n      while (\n        (match = regex.exec(dict.value)) !== null &&\n        match[matchIdx] !== ''\n      ) {\n        // calculate range inside dict.value\n        let start = match.index;\n        if (matchIdx !== 0) {\n          for (let i = 1; i < matchIdx; i++) {\n            start += match[i].length;\n          }\n        }\n        const end = start + match[matchIdx].length;\n        // note that dict will be updated automatically, as it'll change\n        // in the wrapping process, due to the fact that text\n        // nodes will be splitted\n        this.wrapRangeInMappedTextNode(dict, start, end, node => {\n          return filterCb(match[matchIdx], node);\n        }, (node, lastIndex) => {\n          regex.lastIndex = lastIndex;\n          eachCb(node);\n        });\n      }\n      endCb();\n    });\n  }\n\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapRangeFromIndexEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   * @param {Mark~rangeObject} range - the current range object; provided\n   * start and length values will be numeric integers modified from the\n   * provided original ranges.\n   */\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapRangeFromIndexFilterCallback\n   * @param {HTMLElement} node - The text node which includes the range\n   * @param {Mark~rangeObject} range - the current range object\n   * @param {string} match - string extracted from the matching range\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapRangeFromIndexEndCallback\n   */\n  /**\n   * Wraps the indicated ranges across all HTML elements in all contexts\n   * @param {Mark~setOfRanges} ranges\n   * @param {Mark~wrapRangeFromIndexFilterCallback} filterCb\n   * @param {Mark~wrapRangeFromIndexEachCallback} eachCb\n   * @param {Mark~wrapRangeFromIndexEndCallback} endCb\n   * @access protected\n   */\n  wrapRangeFromIndex(ranges, filterCb, eachCb, endCb) {\n    this.getTextNodes(dict => {\n      const originalLength = dict.value.length;\n      ranges.forEach((range, counter) => {\n        let {start, end, valid} = this.checkWhitespaceRanges(\n          range,\n          originalLength,\n          dict.value\n        );\n        if (valid) {\n          this.wrapRangeInMappedTextNode(dict, start, end, node => {\n            return filterCb(\n              node,\n              range,\n              dict.value.substring(start, end),\n              counter\n            );\n          }, node => {\n            eachCb(node, range);\n          });\n        }\n      });\n      endCb();\n    });\n  }\n\n  /**\n   * Unwraps the specified DOM node with its content (text nodes or HTML)\n   * without destroying possibly present events (using innerHTML) and\n   * normalizes the parent at the end (merge splitted text nodes)\n   * @param  {HTMLElement} node - The DOM node to unwrap\n   * @access protected\n   */\n  unwrapMatches(node) {\n    const parent = node.parentNode;\n    let docFrag = document.createDocumentFragment();\n    while (node.firstChild) {\n      docFrag.appendChild(node.removeChild(node.firstChild));\n    }\n    parent.replaceChild(docFrag, node);\n    if (!this.ie) { // use browser's normalize method\n      parent.normalize();\n    } else { // custom method (needs more time)\n      this.normalizeTextNode(parent);\n    }\n  }\n\n  /**\n   * Normalizes text nodes. It's a workaround for the native normalize method\n   * that has a bug in IE (see attached link). Should only be used in IE\n   * browsers as it's slower than the native method.\n   * @see {@link http://tinyurl.com/z5asa8c}\n   * @param {HTMLElement} node - The DOM node to normalize\n   * @access protected\n   */\n  normalizeTextNode(node) {\n    if (!node) {\n      return;\n    }\n    if (node.nodeType === 3) {\n      while (node.nextSibling && node.nextSibling.nodeType === 3) {\n        node.nodeValue += node.nextSibling.nodeValue;\n        node.parentNode.removeChild(node.nextSibling);\n      }\n    } else {\n      this.normalizeTextNode(node.firstChild);\n    }\n    this.normalizeTextNode(node.nextSibling);\n  }\n\n  /**\n   * Callback when finished\n   * @callback Mark~commonDoneCallback\n   * @param {number} totalMatches - The number of marked elements\n   */\n  /**\n   * @typedef Mark~commonOptions\n   * @type {object.<string>}\n   * @property {string} [element=\"mark\"] - HTML element tag name\n   * @property {string} [className] - An optional class name\n   * @property {string[]} [exclude] - An array with exclusion selectors.\n   * Elements matching those selectors will be ignored\n   * @property {boolean} [iframes=false] - Whether to search inside iframes\n   * @property {Mark~commonDoneCallback} [done]\n   * @property {boolean} [debug=false] - Wheter to log messages\n   * @property {object} [log=window.console] - Where to log messages (only if\n   * debug is true)\n   */\n  /**\n   * Callback for each marked element\n   * @callback Mark~markRegExpEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback if there were no matches\n   * @callback Mark~markRegExpNoMatchCallback\n   * @param {RegExp} regexp - The regular expression\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markRegExpFilterCallback\n   * @param {HTMLElement} textNode - The text node which includes the match\n   * @param {string} match - The matching string for the RegExp\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markRegExpOptions\n   * @type {object.<string>}\n   * @property {Mark~markRegExpEachCallback} [each]\n   * @property {Mark~markRegExpNoMatchCallback} [noMatch]\n   * @property {Mark~markRegExpFilterCallback} [filter]\n   */\n  /**\n   * Marks a custom regular expression\n   * @param  {RegExp} regexp - The regular expression\n   * @param  {Mark~markRegExpOptions} [opt] - Optional options object\n   * @access public\n   */\n  markRegExp(regexp, opt) {\n    this.opt = opt;\n    this.log(`Searching with expression \"${regexp}\"`);\n    let totalMatches = 0,\n      fn = 'wrapMatches';\n    const eachCb = element => {\n      totalMatches++;\n      this.opt.each(element);\n    };\n    if (this.opt.acrossElements) {\n      fn = 'wrapMatchesAcrossElements';\n    }\n    this[fn](regexp, this.opt.ignoreGroups, (match, node) => {\n      return this.opt.filter(node, match, totalMatches);\n    }, eachCb, () => {\n      if (totalMatches === 0) {\n        this.opt.noMatch(regexp);\n      }\n      this.opt.done(totalMatches);\n    });\n  }\n\n  /**\n   * Callback for each marked element\n   * @callback Mark~markEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback if there were no matches\n   * @callback Mark~markNoMatchCallback\n   * @param {RegExp} term - The search term that was not found\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markFilterCallback\n   * @param {HTMLElement} textNode - The text node which includes the match\n   * @param {string} match - The matching term\n   * @param {number} totalCounter - A counter indicating the number of all\n   * marks\n   * @param {number} termCounter - A counter indicating the number of marks\n   * for the specific match\n   */\n  /**\n   * @typedef Mark~markAccuracyObject\n   * @type {object.<string>}\n   * @property {string} value - A accuracy string value\n   * @property {string[]} limiters - A custom array of limiters. For example\n   * <code>[\"-\", \",\"]</code>\n   */\n  /**\n   * @typedef Mark~markAccuracySetting\n   * @type {string}\n   * @property {\"partially\"|\"complementary\"|\"exactly\"|Mark~markAccuracyObject}\n   * [accuracy=\"partially\"] - Either one of the following string values:\n   * <ul>\n   *   <li><i>partially</i>: When searching for \"lor\" only \"lor\" inside\n   *   \"lorem\" will be marked</li>\n   *   <li><i>complementary</i>: When searching for \"lor\" the whole word\n   *   \"lorem\" will be marked</li>\n   *   <li><i>exactly</i>: When searching for \"lor\" only those exact words\n   *   will be marked. In this example nothing inside \"lorem\". This value\n   *   is equivalent to the previous option <i>wordBoundary</i></li>\n   * </ul>\n   * Or an object containing two properties:\n   * <ul>\n   *   <li><i>value</i>: One of the above named string values</li>\n   *   <li><i>limiters</i>: A custom array of string limiters for accuracy\n   *   \"exactly\" or \"complementary\"</li>\n   * </ul>\n   */\n  /**\n   * @typedef Mark~markWildcardsSetting\n   * @type {string}\n   * @property {\"disabled\"|\"enabled\"|\"withSpaces\"}\n   * [wildcards=\"disabled\"] - Set to any of the following string values:\n   * <ul>\n   *   <li><i>disabled</i>: Disable wildcard usage</li>\n   *   <li><i>enabled</i>: When searching for \"lor?m\", the \"?\" will match zero\n   *   or one non-space character (e.g. \"lorm\", \"loram\", \"lor3m\", etc). When\n   *   searching for \"lor*m\", the \"*\" will match zero or more non-space\n   *   characters (e.g. \"lorm\", \"loram\", \"lor123m\", etc).</li>\n   *   <li><i>withSpaces</i>: When searching for \"lor?m\", the \"?\" will\n   *   match zero or one space or non-space character (e.g. \"lor m\", \"loram\",\n   *   etc). When searching for \"lor*m\", the \"*\" will match zero or more space\n   *   or non-space characters (e.g. \"lorm\", \"lore et dolor ipsum\", \"lor: m\",\n   *   etc).</li>\n   * </ul>\n   */\n  /**\n   * @typedef Mark~markIgnorePunctuationSetting\n   * @type {string[]}\n   * @property {string} The strings in this setting will contain punctuation\n   * marks that will be ignored:\n   * <ul>\n   *   <li>These punctuation marks can be between any characters, e.g. setting\n   *   this option to <code>[\"'\"]</code> would match \"Worlds\", \"World's\" and\n   *   \"Wo'rlds\"</li>\n   *   <li>One or more apostrophes between the letters would still produce a\n   *   match (e.g. \"W'o''r'l'd's\").</li>\n   *   <li>A typical setting for this option could be as follows:\n   *   <pre>ignorePunctuation: \":;.,-–—‒_(){}[]!'\\\"+=\".split(\"\"),</pre> This\n   *   setting includes common punctuation as well as a minus, en-dash,\n   *   em-dash and figure-dash\n   *   ({@link https://en.wikipedia.org/wiki/Dash#Figure_dash ref}), as well\n   *   as an underscore.</li>\n   * </ul>\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markOptions\n   * @type {object.<string>}\n   * @property {boolean} [separateWordSearch=true] - Whether to search for\n   * each word separated by a blank instead of the complete term\n   * @property {boolean} [diacritics=true] - If diacritic characters should be\n   * matched. ({@link https://en.wikipedia.org/wiki/Diacritic Diacritics})\n   * @property {object} [synonyms] - An object with synonyms. The key will be\n   * a synonym for the value and the value for the key\n   * @property {Mark~markAccuracySetting} [accuracy]\n   * @property {Mark~markWildcardsSetting} [wildcards]\n   * @property {boolean} [acrossElements=false] - Whether to find matches\n   * across HTML elements. By default, only matches within single HTML\n   * elements will be found\n   * @property {boolean} [ignoreJoiners=false] - Whether to ignore word\n   * joiners inside of key words. These include soft-hyphens, zero-width\n   * space, zero-width non-joiners and zero-width joiners.\n   * @property {Mark~markIgnorePunctuationSetting} [ignorePunctuation]\n   * @property {Mark~markEachCallback} [each]\n   * @property {Mark~markNoMatchCallback} [noMatch]\n   * @property {Mark~markFilterCallback} [filter]\n   */\n  /**\n   * Marks the specified search terms\n   * @param {string|string[]} [sv] - Search value, either a search string or\n   * an array containing multiple search strings\n   * @param  {Mark~markOptions} [opt] - Optional options object\n   * @access public\n   */\n  mark(sv, opt) {\n    this.opt = opt;\n    let totalMatches = 0,\n      fn = 'wrapMatches';\n\n    const {\n        keywords: kwArr,\n        length: kwArrLen\n      } = this.getSeparatedKeywords(typeof sv === 'string' ? [sv] : sv),\n      sens = this.opt.caseSensitive ? '' : 'i',\n      handler = kw => { // async function calls as iframes are async too\n        let regex = new RegExp(this.createRegExp(kw), `gm${sens}`),\n          matches = 0;\n        this.log(`Searching with expression \"${regex}\"`);\n        this[fn](regex, 1, (term, node) => {\n          return this.opt.filter(node, kw, totalMatches, matches);\n        }, element => {\n          matches++;\n          totalMatches++;\n          this.opt.each(element);\n        }, () => {\n          if (matches === 0) {\n            this.opt.noMatch(kw);\n          }\n          if (kwArr[kwArrLen - 1] === kw) {\n            this.opt.done(totalMatches);\n          } else {\n            handler(kwArr[kwArr.indexOf(kw) + 1]);\n          }\n        });\n      };\n    if (this.opt.acrossElements) {\n      fn = 'wrapMatchesAcrossElements';\n    }\n    if (kwArrLen === 0) {\n      this.opt.done(totalMatches);\n    } else {\n      handler(kwArr[0]);\n    }\n  }\n\n  /**\n   * Callback for each marked element\n   * @callback Mark~markRangesEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   * @param {array} range - array of range start and end points\n   */\n  /**\n   * Callback if a processed range is invalid, out-of-bounds, overlaps another\n   * range, or only matches whitespace\n   * @callback Mark~markRangesNoMatchCallback\n   * @param {Mark~rangeObject} range - a range object\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markRangesFilterCallback\n   * @param {HTMLElement} node - The text node which includes the range\n   * @param {array} range - array of range start and end points\n   * @param {string} match - string extracted from the matching range\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markRangesOptions\n   * @type {object.<string>}\n   * @property {Mark~markRangesEachCallback} [each]\n   * @property {Mark~markRangesNoMatchCallback} [noMatch]\n   * @property {Mark~markRangesFilterCallback} [filter]\n   */\n  /**\n   * Marks an array of objects containing a start with an end or length of the\n   * string to mark\n   * @param  {Mark~setOfRanges} rawRanges - The original (preprocessed)\n   * array of objects\n   * @param  {Mark~markRangesOptions} [opt] - Optional options object\n   * @access public\n   */\n  markRanges(rawRanges, opt) {\n    this.opt = opt;\n    let totalMatches = 0,\n      ranges = this.checkRanges(rawRanges);\n    if (ranges && ranges.length) {\n      this.log(\n        'Starting to mark with the following ranges: ' +\n        JSON.stringify(ranges)\n      );\n      this.wrapRangeFromIndex(\n        ranges, (node, range, match, counter) => {\n          return this.opt.filter(node, range, match, counter);\n        }, (element, range) => {\n          totalMatches++;\n          this.opt.each(element, range);\n        }, () => {\n          this.opt.done(totalMatches);\n        }\n      );\n    } else {\n      this.opt.done(totalMatches);\n    }\n  }\n\n  /**\n   * Removes all marked elements inside the context with their HTML and\n   * normalizes the parent at the end\n   * @param  {Mark~commonOptions} [opt] - Optional options object\n   * @access public\n   */\n  unmark(opt) {\n    this.opt = opt;\n    let sel = this.opt.element ? this.opt.element : '*';\n    sel += '[data-markjs]';\n    if (this.opt.className) {\n      sel += `.${this.opt.className}`;\n    }\n    this.log(`Removal selector \"${sel}\"`);\n    this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, node => {\n      this.unwrapMatches(node);\n    }, node => {\n      const matchesSel = DOMIterator.matches(node, sel),\n        matchesExclude = this.matchesExclude(node);\n      if (!matchesSel || matchesExclude) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }, this.opt.done);\n  }\n}\n","import MarkJS from './lib/mark';\n\nexport default function Mark(ctx) {\n  const instance = new MarkJS(ctx);\n  this.mark = (sv, opt) => {\n    instance.mark(sv, opt);\n    return this;\n  };\n  this.markRegExp = (sv, opt) => {\n    instance.markRegExp(sv, opt);\n    return this;\n  };\n  this.markRanges = (sv, opt) => {\n    instance.markRanges(sv, opt);\n    return this;\n  };\n  this.unmark = (opt) => {\n    instance.unmark(opt);\n    return this;\n  };\n  return this;\n}"],"x_google_ignoreList":[0,1,2],"mappings":"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"}